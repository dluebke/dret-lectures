<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="hotspot/hotspot/hotspot.xsl"?>
<?hotspot layout-path="hotspot/hotspot/layout" ?>
<?hotspot kilauea-path="hotspot/kilauea" ?>
<?hotspot layout="apiacademy-new" ?>
<hotspot xmlns="http://dret.net/xmlns/hotspot/1" xmlns:hotspot="http://dret.net/xmlns/hotspot/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://dret.net/xmlns/hotspot/1 hotspot/hotspot/schemas/hotspot.xsd">
	<script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script>
	<configuration>
		<link subsections="yes" bookmarks="yes" versions="herman-miller.xml" home="./" help="quick" contents="./" author="http://dret.net/netdret/"/>
		<paths img="img" listing="src"/>
		<outline count-text=" [*]" count-depth="all"/>
		<hyperlink extra=""/>
		<extension file="html" link=""/>
		<counter separator=":&#160;"/>
		<kilauea xmlns="http://xmlns.sharpeleven.net/kilauea">
			<plugins>
				<touch/>
			</plugins>
		</kilauea>
	</configuration>
	<license uri="http://creativecommons.org/licenses/by/3.0/" short="CC 3.0">
		<div class="license">
			<p><a rel="license" title="view full text of license" href="http://creativecommons.org/licenses/by/3.0/"><img alt="Creative Commons License" src="hotspot/hotspot/layout/apiacademy/apiacademy/somerights20.png" border="0" height="31" width="88"/></a></p>
			<p><a class="outlink" rel="license" title="view full text of license" href="http://creativecommons.org/licenses/by/3.0/">This work is licensed under a CC<br/>Attribution 3.0 Unported License</a></p>
		</div>
	</license>
	<title>Herman Miller API Workshop</title>
	<author><a href="http://dret.net/netdret/">Erik Wilde</a> <a href="http://twitter.com/dret" class="twitter-follow-button" data-size="large" title="Erik Wilde on Twitter: @dret">(<code>@dret</code>)</a></author>
	<affiliation><a href="http://www.apiacademy.co/">API Academy</a>, <a href="http://www.ca.com/">CA Technologies</a></affiliation>
	<date short="2018-04">April 16/17, 2018</date>
	<copyright>2018 Erik Wilde</copyright>
	<toc name="toc.html">
		<table rules="all" cellspacing="0" cellpadding="5" width="100%">
			<thead>
				<tr>
					<th valign="bottom">Subject</th>
					<th valign="bottom">Slides</th>
					<th valign="bottom">Additional Resources</th>
				</tr>
			</thead>
			<tbody>
				<hotspot:for-each-presentation>
					<tr class="vevent">
						<td valign="top"><b><span class="summary"><hotspot:title/></span></b></td>
						<td align="center"><hotspot:presentation-link title="Presentation Slides"><hotspot:title form="short"/></hotspot:presentation-link> <span class="toggle"><hotspot:slides>(*&#160;Slides)</hotspot:slides></span></td>
						<td align="center"><hotspot:toc class="resources"/></td>
					</tr>
				</hotspot:for-each-presentation>
			</tbody>
		</table>
	</toc>
	<presentation id="introduction">
		<title>Introduction</title>
		<toc class="resources"><a href="http://www.apiacademy.co/">API Academy</a>&#160;· <a href="http://www.apiacademy.co/microservice-architecture-the-oreilly-book/" title="Mike Amundsen, Matt McLarty, Ronnie Mitra, and Irakli Nadareishvili, 'Microservice Architecture: Aligning Principles, Practices, and Culture', O'Reilly Media, June 2016">MSA Book</a></toc>
		<part id="academy-introduction">
			<title>Introduction</title>
			<slide id="dret">
				<title><code>@dret</code> on Twitter/GitHub</title>
				<img src="dret.png" title="dret" href="http://twitter.com/dret" style=" width : 90% ; height : 70% ; object-fit : contain ; margin : 0% 4% 0% 4% ; "/>
			</slide>
			<slide id="api-academy">
				<title><a href="http://www.apiacademy.co/">API Academy</a></title>
				<img src="academy-logo.png" href="http://www.apiacademy.co/" title="API Academy" style="float: right ; width : 30% ; margin : 4% ; "/>
				<ul>
					<li>Global Team working on <em>API Strategy and Design</em> topics</li>
					<ul>
						<li><a href="http://www.apiacademy.co/team_member/matt-mclarty/">Matt McLarty</a> (Vancouver): <a href="http://twitter.com/MattMcLartyBC" class="twitter-follow-button" title="Matt McLarty on Twitter: @MattMcLartyBC"><code>@MattMcLartyBC</code></a><script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script></li>
						<li><a href="http://www.apiacademy.co/team_member/mike-amundsen/">Mike Amundsen</a> (Cincinnati): <a href="http://twitter.com/mamund" class="twitter-follow-button" title="Mike Amundsen on Twitter: @mamund"><code>@mamund</code></a><script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script></li>
						<li><a href="http://www.apiacademy.co/team_member/mehdi-medjaoui/">Mehdi Medjaoui</a> (San Francisco): <a href="http://twitter.com/medjawii" class="twitter-follow-button" title="Mehdi Medjaoui on Twitter: @medjawii"><code>@medjawii</code></a><script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script></li>
						<li><a href="http://www.apiacademy.co/team_member/ronnie-mitra/">Ronnie Mitra</a> (London): <a href="http://twitter.com/mitraman" class="twitter-follow-button" title="Ronnie Mitra on Twitter: @mitraman"><code>@mitraman</code></a><script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script></li>
						<li><a href="http://www.apiacademy.co/team_member/erik-wilde/">Erik Wilde</a> (Zürich): <a href="http://twitter.com/dret" class="twitter-follow-button" title="Erik Wilde on Twitter: @dret"><code>@dret</code></a><script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script></li>
					</ul>
					<li>Evangelizing ideas and technologies</li>
					<ul>
						<li>Speaking (conferences, events)</li>
						<li>Teaching (workshops, bootcamps)</li>
						<li>Publishing (blogs, articles, books, <a href="https://soundcloud.com/user-426834320">podcasts</a>)</li>
						<li>Doing (side projects on API-related topics)</li>
						<li>Standardizing (participating in specification work)</li>
					</ul>
				</ul>
			</slide>
			<slide id="msa-book">
				<title>Microservice Architecture</title>
				<img src="msa-cover.jpg" href="http://transform.ca.com/API-microservice-architecture-oreilly-book.html" title="Microservice Architecture: Aligning Principles, Practices, and Culture" style="float: right ; height : 55% ; margin : 4% ; "/>
				<ul>
					<li><q>Microservice Architecture: Aligning Principles, Practices, and Culture</q></li>
					<li><a href="http://www.apiacademy.co/microservice-architecture-the-oreilly-book/">Authored by</a> <a href="http://www.apiacademy.co/">API Academy</a> members Irakli Nadareishvili, Ronnie Mitra, Matt McLarty, and Mike Amundsen</li>
					<ul>
						<li>Get <a href="http://transform.ca.com/API-microservice-architecture-oreilly-book.html">free electronic version courtesy of CA Technologies</a></li>
						<li>Get <a href="http://shop.oreilly.com/product/0636920050308.do">a hardcopy version</a></li>
					</ul>
				</ul>
			</slide>
			<slide id="dret">
				<title>About Me</title>
				<ul>
					<li><a href="http://dret.net/netdret/publications#wil97b">Ph.D. in Communications Systems</a> from <a href="http://www.ethz.ch/">ETH Zürich</a></li>
					<li>Working on Web Architecture after writing <a href="http://dret.net/netdret/publications#wil98">the first Web Technology book</a></li>
					<li>UC Berkeley (2006-2011), working on <a href="http://dret.net/netdret/publications#wil09g">Service Models for Open Government</a></li>
					<li>EMC (2011-2014), working on transforming software products into service platforms</li>
					<li>Siemens (2014-2015), working on using <em title="Internet of Things">IoT</em> to build <em title="Web of Things">WoT</em> (<q>APIs for Things</q>)</li>
					<li>Joined <a href="http://www.ca.com/" title="CA Technologies">CA</a>'s <a href="http://www.apiacademy.co/">API Academy</a> in 2016 and now all about API Strategy and Design</li>
					<li>Active in the usual places such as <a href="http://twitter.com/dret" title="@dret">Twitter</a>, <a href="http://github.com/dret" title="dret">GitHub</a>, <a href="http://dret.typepad.com/dretblog/">my blog</a>, <a href="http://www.linkedin.com/in/netdret">LinkedIn</a>, and <a href="https://www.flickr.com/photos/dret/" title="dret">flickr</a></li>
				</ul>
			</slide>
		</part>
		<part id="schedule">
			<title>Workshop Schedule</title>
			<slide id="day-1">
				<title>Schedule Day 1 (Monday, April 16)</title>
				<ul>
					<li>9.00-9.15: <link href="introduction">Introduction</link></li>
					<li>9.15-12.15: API Business Value and Case Studies</li>
					<li>13.00-13.30: <link href="design"/></li>
					<li>13.30-14.00: <link href="styles"/></li>
					<li>14.00-14.30: <link href="standards"/></li>
					<li>14.45-15.30: <link href="representations"/></li>
					<li>15.30-16.30: <link href="hypermedia"/></li>
					<li>16.00-16.30: <link href="change-management"/></li>
				</ul>
			</slide>
			<slide id="day-2">
				<title>Schedule Day 2 (Tuesday, April 17)</title>
				<ul>
					<li>9.00-12.15: Managing APIs</li>
					<li>13.00-13.45: <link href="microservices"/></li>
				</ul>
			</slide>
		</part>
		<part id="conclusions">
			<title>Conclusions</title>
			<slide id="q-and-a">
				<title>Thanks! Q&amp;A</title>
				<img src="where-to.png" title="What's Next?" style="float: right ; width : 30% ; margin : 4% ; "/>
				<ul>
					<li>Slides online: <a href="http://dret.net/lectures/herman-miller-2018"><code>dret.net/lectures/herman-miller-2018</code></a></li>
					<li>Slide sources: <a href="http://github.com/dret/lectures/tree/master/herman-miller-2018"><code>dret/lectures</code></a> on <a href="http://github.com/">GitHub</a></li>
					<li>Me: <a href="http://dret.net/netdret/"><code>http://dret.net/netdret/</code></a></li>
					<li>Twitter: <a href="http://twitter.com/dret" class="twitter-follow-button" data-size="large" title="Erik Wilde on Twitter: @dret"><code>@dret</code></a></li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="styles">
		<title>API Styles</title>
		<toc class="resources"><a href="http://dret.net/netdret/publications#pau09a" title='Cesare Pautasso and Erik Wilde, "Why is the Web Loosely Coupled? A Multi-Faceted Metric for Service Design", 18th International World Wide Web Conference (WWW2009), Madrid, Spain, April 2009'>Loose Coupling</a>&#160;· <a href="http://apistylebook.com/" title='Arnaud Lauret, "API Stylebook"'>API Stylebook</a></toc>
		<part id="api-language">
			<title>APIs are Languages</title>
			<slide id="problem-solving">
				<title>Distributed Problem Solving</title>
				<ul>
					<li>APIs are part of distributed problem solving</li>
					<li>Ideal APIs can be used for a range of problems</li>
					<li>Problem-solving often requires combining APIs</li>
					<li><q>Language families</q> make it easier to learn and use new APIs</li>
				</ul>
			</slide>
			<slide id="api-conversation">
				<title>APIs Interactions are Conversations</title>
				<ul>
					<li>APIs support conversations between interacting peers</li>
					<ul>
						<li>Some conversations are point-to-point (how to find the peer?)</li>
						<li>Some conversations are point-to-multipoint (how are groups managed?)</li>
						<li>Some conversations are point-to-ether (what does the ether do?)</li>
					</ul>
					<li>API technology does not determine the API conversation style</li>
					<ul>
						<li>HTTP can be used for asynchronous conversations (<q href="http://www.webhooks.org/">WebHooks</q> pattern)</li>
						<li>Synchronous conversations can be layered on top of asynchronous foundations</li>
					</ul>
					<li>Conversation goals should determine the conversation style</li>
				</ul>
			</slide>
			<slide id="style-metaphors">
				<title>API Style Metaphors</title>
				<ul>
					<li><link href="tunnel-style"/>: Function calls in procedural programming</li>
					<li><link href="uri-style"/>: Data access objects</li>
					<li><link href="hypermedia-style"/>: Browsing the Web</li>
					<li><link href="query-style"/>: Databases and database queries</li>
					<li><link href="event-style"/>: Event-based programming</li>
				</ul>
			</slide>
		</part>
		<part id="tunnel-style">
			<title>Tunnel Style</title>
			<slide id="tunnel-style-image">
				<title>One Tunnel to Call them All</title>
				<img title="Tunnel Style" src="api-styles-tunnel.png" style=" width : 90% ; height : 70% ; object-fit : contain ; margin : 0% 4% 0% 4% ; "/>
			</slide>
			<slide id="rpc-over-http">
				<title>Distributed Programming</title>
				<ul>
					<li>Rooted in <em>Remote Procedure Call (RPC)</em> patterns</li>
					<li>Functions are the main abstraction and invoked at known <em>endpoints</em></li>
					<li>Resource identifiers typically are context-dependent</li>
					<li>Suffers from the typical RPC problems at bigger scale</li>
					<ul>
						<li>Failure is hard to deal with (function calls always succeed)</li>
						<li>Scoped identifiers result in naming challenges and compromised network effect</li>
					</ul>
					<li>Convenient for developers looking to <q>code like a local program</q></li>
				</ul>
			</slide>
		</part>
		<part id="uri-style">
			<title>URI Style</title>
			<slide id="uri-style-image">
				<title>Listing All Resources</title>
				<img title="URI Style" src="api-styles-uri.png" style=" width : 90% ; height : 70% ; object-fit : contain ; margin : 0% 4% 0% 4% ; "/>
			</slide>
			<slide id="webby-identifiers">
				<title>Identifiers for Resources</title>
				<ul>
					<li>Makes a major step towards a more webby service design</li>
					<ul>
						<li>Resources are identified by URIs and thus globally unique</li>
						<li>Data context may be established by using URI identifiers for resources</li>
						<li>Navigational context is missing because of a lack of links</li>
					</ul>
					<li>One necessary step in the evolution of designing decentralized systems</li>
					<ul>
						<li><em>Web of Data</em> is a good starting point</li>
						<li><em>Web of Services</em> is what makes the Web what it is</li>
					</ul>
					<li>Developers are tempted/required to hardcode control flows</li>
					<ul>
						<li>No navigational guidance provided by the API</li>
						<li>Guidance must be hand-crafted or clients are forced to do trial-and-error</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part id="hypermedia-style">
			<title>Hypermedia Style</title>
			<slide id="hypermedia-style-image">
				<title>Linking All Resources</title>
				<img title="Hypermedia Style" src="api-styles-hypermedia.png" style=" width : 90% ; height : 70% ; object-fit : contain ; margin : 0% 4% 0% 4% ; "/>
			</slide>
			<slide id="webby-style">
				<title>Webby APIs</title>
				<ul>
					<li>Based on mixing data and controls in representations</li>
					<ul>
						<li><em>Data</em> represents the current resource state</li>
						<li><em>Controls</em> represent the advertised next options for clients</li>
					</ul>
					<li>Controls allow clients to work across individual APIs</li>
					<ul>
						<li>APIs expose sets of resources and provide links</li>
						<li>Clients follow links without being aware of API boundaries</li>
					</ul>
					<li>Developers must code differently from usual programming flows</li>
					<ul>
						<li>Applications are driven by the responses that client code receives</li>
						<li>Imperative programming is not the best fit for this kind of flow</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part id="query-style">
			<title>Query Style</title>
			<slide id="query-style-image">
				<title>Querying into Server-Side Models</title>
				<img title="Query Style" src="api-styles-query.png" style=" width : 90% ; height : 70% ; object-fit : contain ; margin : 0% 4% 0% 4% ; "/>
			</slide>
			<slide id="database-style">
				<title>Querying Structured Data</title>
				<ul>
					<li>The API provides access to a rich interconnected data structure</li>
					<ul>
						<li>Clients know the data model and understand how to query it</li>
						<li>Clients want a small subset of the available data</li>
					</ul>
					<li>Querying into structure data needs an agreement on data and querying</li>
					<ul>
						<li>Query-style APIs define a <em>metamodel</em> that all data models must use</li>
						<li>Query-style APIs define a <em>query language</em> for querying data</li>
					</ul>
					<li><em>Loose coupling</em> depends on if and how clients adjust to schema changes</li>
					<ul>
						<li>Is it possible for clients to find out about schema changes?</li>
						<li>Do clients have to worry about schema changes?</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part id="event-style">
			<title>Event-Based Style</title>
			<slide id="event-style-image">
				<title>Event Listening</title>
				<img title="Event-based Style" src="api-styles-event.png" style=" width : 90% ; height : 70% ; object-fit : contain ; margin : 0% 4% 0% 4% ; "/>
			</slide>
			<slide id="fire-and-forget">
				<title>Fire and Forget</title>
				<ul>
					<li>Synchronous communications result in tighter coupling between peers</li>
					<li>Asynchronous communications can make data provision easier</li>
					<ul>
						<li>Data is tagged and submitted into some <em>messaging fabric</em></li>
						<li>The fabric takes care of notifying and delivering data to consumers</li>
					</ul>
					<li>The fabric is beyond the <em>smart endpoints and dumb pipes</em> idea</li>
					<ul>
						<li><em>Smart pipes</em> are not bad by itself but often have problems scaling</li>
					</ul>
					<li>Managing the fabric becomes an essential part of making code work</li>
					<ul>
						<li>Who is producing data?</li>
						<li>Who is consuming data?</li>
						<li>What are the ways in which data can or must be tagged?</li>
						<li>How is the namespace of data tagging managed?</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part id="choosing-style">
			<title>Choosing an API Style</title>
			<slide id="api-style-maslow">
				<title>API Styles are Tools</title>
				<img title="Hammer and Screw" href="https://www.flickr.com/photos/justinbaeder/5317820857" src="maslow-hammer-nail.jpg" style=" width : 90% ; height : 70% ; object-fit : contain ; margin : 0% 4% 0% 4% ; "/>
			</slide>
			<slide id="api-style-properties">
				<title>API Style Properties</title>
				<ul>
					<li>API styles influence important API properties</li>
					<ul>
						<li><em>Scalability:</em> Number of APIs, API teams, API consumers, and API interactions</li>
						<li><em>Usability:</em> Problem domain, established styles, available tooling</li>
						<li><em>Changeability:</em> BFF, known/unknown group of consumers</li>
						<li><em>Performance:</em> What are critical issues in known scenarios</li>
						<li><em>Reliability:</em> Operational concerns and centralization/decentralization</li>
					</ul>
				</ul>
			</slide>
			<slide id="api-style-context">
				<title>Context Considerations</title>
				<ul>
					<li><em>Backend for Frontend (BFF)</em> implies tight coupling producer/consumer</li>
					<ul>
						<li>API style and API design can be coordinated with the consumer</li>
					</ul>
					<li><em>Private APIs</em> implies a smaller group of potential consumers</li>
					<ul>
						<li>Style and design can be guided by internal guidelines/practices</li>
					</ul>
					<li><em>Partner APIs</em> implies a well-known group of consumers</li>
					<ul>
						<li>Broader appeal to consumers necessary</li>
					</ul>
					<li><em>Public APIs</em> is the most loosely couple group of consumers</li>
					<ul>
						<li>No control over consumers and their preferences/tools and development cycles</li>
					</ul>
				</ul>
			</slide>
			<slide id="style-implementations">
				<title>API Styles in the Wild</title>
				<ul>
					<li><link href="tunnel-style"/>: XML-RPC, SOAP, gRPC</li>
					<li><link href="uri-style"/>: Swagger/OpenAPI</li>
					<li><link href="hypermedia-style"/>: HAL, Siren, Atom</li>
					<li><link href="query-style"/>: GraphQL, OData, SPARQL</li>
					<li><link href="event-style"/>: MQ, WebSub, MQTT, XMPP, AMQP</li>
				</ul>
			</slide>
		</part>
		<part id="style-conclusions">
			<title>Conclusions</title>
			<slide id="no-style-hammer">
				<title>There is no Style Hammer</title>
				<ul>
					<li>API styles can be combined</li>
					<li>Style coherence makes a API landscape more usable</li>
					<li>Style fundamentalism may pick the wrong tool for a problem</li>
					<li>Be aware of styles and pick the one that works best</li>
				</ul>
			</slide>
			<slide id="q-and-a">
				<title>Thanks! Q&amp;A</title>
				<img src="where-to.png" title="What's Next?" style="float: right ; width : 30% ; margin : 4% ; "/>
				<ul>
					<li>Slides online: <a href="http://dret.net/lectures/herman-miller-2018"><code>dret.net/lectures/herman-miller-2018</code></a></li>
					<li>Slide sources: <a href="http://github.com/dret/lectures/tree/master/herman-miller-2018"><code>dret/lectures</code></a> on <a href="http://github.com/">GitHub</a></li>
					<li>Me: <a href="http://dret.net/netdret/"><code>http://dret.net/netdret/</code></a></li>
					<li>Twitter: <a href="http://twitter.com/dret" class="twitter-follow-button" data-size="large" title="Erik Wilde on Twitter: @dret"><code>@dret</code></a></li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="microservices">
		<title>Microservices</title>
		<toc class="resources"><a href="http://www.apiacademy.co/microservice-architecture-the-oreilly-book/" title="Mike Amundsen, Matt McLarty, Ronnie Mitra, and Irakli Nadareishvili, 'Microservice Architecture: Aligning Principles, Practices, and Culture', O'Reilly Media, June 2016">MSA Book</a>&#160;· <a href="https://martinfowler.com/microservices/" title="Martin Fowler's Microservices Resource Guide">Microservices Resource Guide</a></toc>
		<part id="microservices-pattern">
			<title>Microservices as a Pattern</title>
			<slide id="microservices-scalability">
				<title>Bottom-Up Motivation: Service Scalability</title>
				<ul>
					<li>Build modularized components that can be scaled individually</li>
					<ul>
						<li><em>Monitoring</em> allows insights into system status and load</li>
						<li><em>Rapid Provisioning</em> allows to react quickly when new capacity is required</li>
						<li><em>Rapid Deployment</em> means simple ways to develop/test/start/scale services</li>
					</ul>
					<li>Microservice implementations are more flexible than integrated approaches</li>
					<ul>
						<li>Scaling can be done per service instead of scaling bigger deployment units</li>
						<li>Code can be retired more easily by removing services from deployment</li>
						<li>Fewer unintended side-effects since all interactions are through APIs</li>
					</ul>
				</ul>
			</slide>
			<slide id="microservices-digital-transformation">
				<title>Top-Down Motivation: Digital Transformation</title>
				<ul>
					<li>IT capabilities and management often are not aligned</li>
					<ul>
						<li><em>Capabilities</em> are growing and business demands are growing as well</li>
						<li><em>Management</em> becomes complex and impacts execution speed</li>
					</ul>
					<li>There is a difference in separating interfaces and implementations</li>
					<ul>
						<li><em>Interfaces</em> are useful for accessing capabilities</li>
						<li><em>Implementations</em> must support easy modifications and additions</li>
					</ul>
					<li>The first wave of <em>API focus (SOA)</em> focused on interfaces only</li>
					<ul>
						<li>Focusing on APIs as <em>business-aligned capabilities</em> is a necessary first step</li>
						<li>Agility suffers when implementations are not business-aligned</li>
						<li><a href="https://en.wikipedia.org/wiki/Conway%27s_law">Conway's Law</a> means that changing implementation structure can be hard</li>
					</ul>
				</ul>
			</slide>
			<slide id="msa-conway">
				<title>Conway's Law</title>
				<blockquote><q href="http://www.melconway.com/Home/Conways_Law.html">Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization's communication structure.</q> (<a href="https://en.wikipedia.org/wiki/Melvin_Conway">Mel Conway</a>)</blockquote>
			</slide>
			<slide id="soapy-soa">
				<title>The SOA Crisis</title>
				<ul>
					<li>SOAP-style SOA are traditional IT monoliths exposing some capabilities</li>
					<li>MSA #1 goal is to create a loosely coupled service landscape</li>
					<ul>
						<li>Shared data storage creates coupling</li>
						<li>Shared infrastructure creates coupling</li>
						<li>Shared libraries create coupling</li>
						<li>Loose coupling allows to pick the right tool for the job</li>
						<li>Loose coupling allows to refactor/retire as required</li>
						<li>Loose coupling blurs the public/partner/private lines</li>
					</ul>
					<li><em>Using APIs</em> is one of the few overlaps between SOAP-style SOA and MSA</li>
				</ul>
			</slide>
			<slide id="microservices-are-soa">
				<title>Microservices are SOA!</title>
				<img title="Microservices are SOA!" src="microservices-are-soa.jpg" style=" width : 90% ; height : 70% ; object-fit : contain ; margin : 0% 4% 0% 4% ; "/>
			</slide>
			<slide id="microservices-are-good-soa">
				<title>Microservices are SOA done Right!</title>
				<ul>
					<li><em>Decouple implementations</em> and not just interfaces</li>
					<li><em>Velocity</em> is determined by how hard it is to make changes</li>
					<li>The biggest problem is not <em>access to capabilities</em> but <em>capability agility</em></li>
					<ul>
						<li>Providing access to capabilities is better than doing nothing</li>
						<li><em>Agile management of the capability landscape</em> goes further than that</li>
					</ul>
					<li>Microservices apply <em>Web architecture</em> to <em>Enterprise IT</em></li>
					<ul>
						<li>Implementation details are completely invisible to service users</li>
						<li>Service consumption <em>only</em> uses well-defined and uniform interfaces</li>
					</ul>
				</ul>
			</slide>
			<slide id="monolith">
				<title>The Dreaded Monolith</title>
				<img title="Where you come from…" href="https://upload.wikimedia.org/wikipedia/commons/7/7b/Weltmaschine_gsellmann1.JPG" src="monolith.jpg" style=" width : 90% ; height : 70% ; object-fit : contain ; margin : 0% 4% 0% 4% ; "/>
			</slide>
			<slide id="msa-neat">
				<title>Microservices: The Starting Point</title>
				<img title="Where you think you're going…" href="https://static.pexels.com/photos/12598/96917deb7705adcee76b65caf8c652b1.jpg" src="microservices-ideal.jpg" style=" width : 90% ; height : 70% ; object-fit : contain ; margin : 0% 4% 0% 4% ; "/>
			</slide>
			<slide id="msa-messy">
				<title>Microservices Over Time</title>
				<img title="By Lachlan Donald from Melbourne, Australia (Sharpest tool in the shed) [CC BY 2.0 (http://creativecommons.org/licenses/by/2.0)], via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File%3AHuge_collection_of_tools_in_a_store_in_Chloride%2C_a_ghost_town_in_New_Mexico%2C_USA_-_July_2013.jpg" src="microservices-reality.jpg" style=" width : 90% ; height : 70% ; object-fit : contain ; margin : 0% 4% 0% 4% ; "/>
			</slide>
			<slide id="soapy-discovery">
				<title>Old School Discovery</title>
				<ul>
					<li>SOAP's answer to service discovery was UDDI</li>
					<ul>
						<li>The biggest failure of the SOAP Web Services stack</li>
						<li>Allowing only one specific kind of service design</li>
						<li>Focusing on the function signature as a service's main description</li>
					</ul>
					<li>Building directories from carefully described and categorized entries</li>
					<ul>
						<li>Feels like the Yahoo! of service discovery: The one true model approach</li>
					</ul>
					<li>What does a Google of Service Discovery look like?</li>
					<ul>
						<li>Starting from services, <a href="http://webconcepts.info/specs/IETF/I-D/draft-wilde-service-link-rel">find available description/documentation resources</a></li>
						<li>Index description/documentation resources for subsequent discovery</li>
						<li>Add support for additional description/documentation formats as required</li>
					</ul>
				</ul>
			</slide>
			<slide id="ms-description-discovery">
				<title>Decentralize Description and Discovery</title>
				<ul>
					<li>MSA is all about making services more independent and self-contained</li>
					<ul>
						<li>Discovery should follow the same pattern: Avoid centralization, be polyglot</li>
					</ul>
					<li>Decentralized discovery is based on pulling/crawling diverse data</li>
					<ol>
						<li>Start by <a href="http://webconcepts.info/specs/IETF/I-D/draft-wilde-service-link-rel">finding available description/documentation resources</a></li>
						<li>Process these based on supported description/documentation formats</li>
						<li>Increase support if required by the evolving ecosystem</li>
						<li>Provide discovery services based on the resulting service ecosystem snapshot</li>
					</ol>
					<li>Added benefit: Reality-based view on description/documentation/service ecosystem</li>
				</ul>
			</slide>
		</part>
		<part id="msa-journey">
			<title>The MSA Journey</title>
			<slide id="change">
				<title>Transformation: Changing vs. Changeable</title>
				<ul>
					<li><em>Changing</em> implies a one-time activity</li>
					<li><em>Changeable</em> implies an intrinsic property</li>
					<blockquote>
						<p>Don't focus on what to <b>change into</b>;<br/>Focus on <b>embracing change</b> as your mode of existence.</p>
					</blockquote>
				</ul>
			</slide>
			<slide id="balance">
				<title>Delicate Balance</title>
				<ul>
					<li><em>Preserve:</em> Functional core and business foundations</li>
					<li><em>Nourish:</em> Ability to change and situational awareness</li>
					<li><a href="http://agilemanifesto.org/">Agile</a> moves from an IT approach to a business approach</li>
					<ul>
						<li><em>Individuals and interactions</em> over processes and tools</li>
						<li><em>Working software</em> over comprehensive documentation</li>
						<li><em>Customer collaboration</em> over contract negotiation</li>
						<li><em>Responding to change</em> over following a plan</li>
					</ul>
				</ul>
			</slide>
			<slide id="strangler">
				<title>Strangling the Monolith</title>
				<img title="Strangler Vine" href="https://commons.wikimedia.org/wiki/File:Strangler_tree.jpg" src="strangler-vine.jpg" style=" width : 90% ; height : 70% ; object-fit : contain ; margin : 0% 4% 0% 4% ; "/>
			</slide>
			<slide id="good-strangling">
				<title>How to Strangle Well</title>
				<ul>
					<li>Manage access to old/new capabilities through a router or gateway</li>
					<ul>
						<li>Transitioning is a management process old/new should be unaware of</li>
					</ul>
					<li>Data sync/update is a separately managed process</li>
					<ul>
						<li>Sophistication and cost of sync/update depends on consistency requirements</li>
						<li>When one of the services disappears sync/update can be removed</li>
					</ul>
					<li>Manage/monitor transition of service replacement</li>
					<ul>
						<li>At some point in time decommissioning may be the most economical option</li>
						<li>Until then the <em>strangled monolith</em> is the best case scenario</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part id="culture-and-organization">
			<title>Culture and Organization</title>
			<slide id="culture">
				<title>Cultural Changes</title>
				<ul>
					<li>Remove red tape and embrace diversity</li>
					<li>Business environments change faster than ever</li>
					<ul>
						<li><em>Common question:</em> How to change into a more successful organization</li>
						<li><em>Better question:</em> How to become an organization that is better at changing</li>
					</ul>
					<li>The Web succeeded because it out-innovated everything else</li>
					<ul>
						<li>Permissionless decentralized innovation</li>
						<li>Data-driven decisions (traffic drives visibility and success)</li>
						<li>Continuous change enabled through loose coupling</li>
					</ul>
				</ul>
			</slide>
			<slide id="organization">
				<title>Organizational Changes</title>
				<blockquote><q href="http://www.melconway.com/Home/Conways_Law.html">Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization's communication structure.</q> (<a href="https://en.wikipedia.org/wiki/Melvin_Conway">Mel Conway</a>)</blockquote>
				<ul>
					<li>Learn from all of <em>Conway's laws</em></li>
					<ol>
						<li>Focus on communications (<q>Communication dictates design</q>)</li>
						<li>Support continuous process (<q>Be able to do it over</q>)</li>
						<li>Improve team independence (<q>Interdependent teams create interdependent systems</q>)</li>
						<li>Keep project scope small (<q>Big problems/systems tend to shape-shift</q>)</li>
					</ol>
				</ul>
			</slide>
			<slide id="evolution">
				<title>MSA Evolution</title>
				<ul>
					<li>Embrace change and start changing today</li>
					<ul>
						<li>Start small and learn by doing</li>
						<li>MSA management is about empowering</li>
					</ul>
					<li>MSA creates an environment that is designed to be change-friendly</li>
					<ul>
						<li><em>MSA technologies</em> allow teams to deliver as fast as possible</li>
						<li><em>APIs</em> allows teams/partners to access new products as easily as possible</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part id="microservices-and-apis">
			<title>Microservices and APIs</title>
			<slide id="microservice-api">
				<title>There is no <q>Microservices API</q></title>
				<ul>
					<li>Microservices are all about <em>how to implement services</em></li>
					<li>APIs are all about <em>how to interact with services</em></li>
					<li>Microservices are an implementation detail from the API perspective</li>
					<li>Microservice-implemented APIs might exhibit certain properties</li>
					<ul>
						<li>Changing more often because of faster implementation cycles</li>
						<li>More diverse <em>API landscapes</em> because of more autonomy</li>
						<li>Smaller scope because of solutions targeted at specific problems</li>
					</ul>
				</ul>
			</slide>
			<slide id="microservice-api-design">
				<title>Designing Microservice APIs</title>
				<ul>
					<li>API consumers just use an <em>API</em> and not a <em>Microservice API</em></li>
					<ul>
						<li>Microservice API design is no different from API design in general</li>
						<li>Tighter coupling may be acceptable for vertical scenarios (<a href="http://samnewman.io/patterns/architectural/bff/">BFF pattern</a>)</li>
					</ul>
					<li>Balancing autonomy/diversity and coherence/usability is necessary</li>
					<ul>
						<li>Microservices should have <em>freedom</em> to design their APIs</li>
						<li>API design should be driven by <em>design culture and patterns</em></li>
						<li>Microservices strategy needs to distill/document/distribute design patterns</li>
					</ul>
				</ul>
			</slide>
			<slide id="microservice-api-focus">
				<title>Focus Areas for Microservice APIs</title>
				<ul>
					<li>Be explicit about openness and extensibility</li>
					<li>Provide <em>glue</em> that makes combining services easy</li>
					<ul>
						<li>At the minimal level, always use global, unique, and persistent <em>identifiers</em></li>
						<li>Consider using <em>hypermedia</em> as a way to support service orchestration</li>
					</ul>
					<li>Be explicit about how services signal end-of-life</li>
				</ul>
			</slide>
		</part>
		<part id="microservices-conclusions">
			<title>Conclusions</title>
			<slide id="msa-matters">
				<title>Microservice Architecture Matters</title>
				<ul>
					<li>MSA promotes agility (API designs should evolve)</li>
					<li>MSA promotes diversity (in design and implementation)</li>
					<li>MSA means more services (and the need for good DX across them)</li>
					<li>With MSA comes the need for a mature API strategy</li>
				</ul>
			</slide>
			<slide id="q-and-a">
				<title>Thanks! Q&amp;A</title>
				<img src="where-to.png" title="What's Next?" style="float: right ; width : 30% ; margin : 4% ; "/>
				<ul>
					<li>Slides online: <a href="http://dret.net/lectures/herman-miller-2018"><code>dret.net/lectures/herman-miller-2018</code></a></li>
					<li>Slide sources: <a href="http://github.com/dret/lectures/tree/master/herman-miller-2018"><code>dret/lectures</code></a> on <a href="http://github.com/">GitHub</a></li>
					<li>Me: <a href="http://dret.net/netdret/"><code>http://dret.net/netdret/</code></a></li>
					<li>Twitter: <a href="http://twitter.com/dret" class="twitter-follow-button" data-size="large" title="Erik Wilde on Twitter: @dret"><code>@dret</code></a></li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="representations">
		<title short="Representations">Representations for APIs</title>
		<toc class="resources"><a href="http://www.webconcepts.info/concepts/media-type/" title="Web Concepts: Media Types">Media Types</a>&#160;· <a href="http://www.w3.org/TR/xml/" title='Tim Bray, Jean Paoli, C. Michael Sperberg-McQueen, Eve Maler, and François Yergeau, "Extensible Markup Language (XML) 1.0 (Fifth Edition)", W3C Recommendation REC-xml-20081126, November 2008'>XML</a>&#160;· <a href="http://webconcepts.info/specs/IETF/RFC/8259" title='Tim Bray, "The JavaScript Object Notation (JSON) Data Interchange Format", IETF RFC 8259, December 2017'>JSON</a>&#160;· <a href="http://webconcepts.info/specs/IETF/RFC/4287" title='Mark Nottingham and Robert Sayre, "The Atom Syndication Format", IETF RFC 4287, December 2005'>Atom</a>&#160;· <a href="https://www.w3.org/TR/activitystreams-core/" title='James Snell and Evan Prodromou, "Activity Streams 2.0", W3C Recommendation REC-activitystreams-core-20170523, May 2017'>Activity Streams</a>&#160;· <a href="https://jsonfeed.org/">JSON Feed</a>&#160;· <a title='Mark Nottingham and Erik Wilde, "Problem Details for HTTP APIs", Internet RFC 7807, March 2016' href="http://webconcepts.info/specs/IETF/RFC/7807">RFC 7807</a></toc>
		<part id="intro">
			<title>Introduction</title>
			<slide id="digital-shadow">
				<title>Digital Shadows</title>
				<ul>
					<li><em>Digital Transformation</em> mirrors/designs/builds a world in the digital realm</li>
					<ul>
						<li>Represent your business (processes) in IT to allow automation</li>
						<li>Business transformation can be (more) easily executed on the IT side</li>
						<li>IT insights and changes directly translate to the business side</li>
					</ul>
					<li>IT always has been <em>modeling</em> and <em>implementing</em> <q>reality</q></li>
					<ul>
						<li><em>Essential complexity</em> is a result of domain complexity</li>
						<li><em>Accidental complexity</em> is a result of implementation complications</li>
					</ul>
				</ul>
			</slide>
			<slide id="resources">
				<title>Resources</title>
				<ul>
					<li>APIs are languages that allow providers and consumers to communicate</li>
					<ul>
						<li>API design is about supporting <em>conversations</em> between peers</li>
						<li><em>Conversations</em> revolve around resource <em>interactions</em></li>
						<li><em>Interactions</em> are about exchanging resource representations</li>
					</ul>
					<li>Resources are anything that the API language should talk about</li>
					<ul>
						<li>Resources can be real-world concepts such as <em>products</em></li>
						<li>Resources can be immaterial concepts such as <em>product descriptions</em></li>
						<li>Resources can be ephemeral concepts such as <em>product orders</em></li>
						<li>Resources can be temporary concepts such as <em>current orders for a product</em></li>
					</ul>
				</ul>
			</slide>
			<slide id="digital-representations">
				<title>Digital Representations</title>
				<ul>
					<li>Resources are concepts on the service side</li>
					<ul>
						<li>They are essential to the service model</li>
						<li>Resources are not directly accessible or available</li>
						<li>Clients only use <em>representations</em> when interacting with services</li>
					</ul>
					<li>Separate shallow <em>service surfaces</em> and deep <em>service models</em></li>
					<ul>
						<li><em>Service surfaces</em> are minimal sets of representations and interactions</li>
						<li><em>Service models</em> are domain models for experts and implementers</li>
					</ul>
					<li>Separating surfaces and models reduces coupling</li>
				</ul>
			</slide>
			<slide id="vocabularies">
				<title>Vocabularies</title>
				<ul>
					<li>Vocabularies define the language for API interactions</li>
					<ul>
						<li>They help to understand the scope and breadth of resource representations</li>
					</ul>
					<li>Shallow and simple vocabularies are essential for loose coupling</li>
					<ul>
						<li>Shallowness avoids unnecessary details and deep model dependencies</li>
						<li>Simplicity allows clients to more easily understand the <em>API language</em></li>
					</ul>
				</ul>
			</slide>
		</part>
		<part id="what-how">
			<title>What and How to Represent</title>
			<slide id="representing-what">
				<title>What to Represent</title>
				<ul>
					<li>Representations are determined by the <link href="styles">API style</link></li>
					<ul>
						<li><link href="tunnel-style">Tunnel style</link> represents function calls (names and parameters/results)</li>
						<li><link href="uri-style">URI style</link> represents resources for CRUD operations</li>
						<li><link href="hypermedia-style">Hypermedia style</link> represents resource for REST interactions</li>
						<li><link href="query-style">Query style</link> represents queries and query results</li>
						<li><link href="event-style">Event-based style</link> represents events that are produced/consumed</li>
					</ul>
					<li>Some styles especially benefit from <q>common representation patterns</q></li>
					<ul>
						<li><em>Tunnel style</em> may benefit from a general schema for function names and parameters</li>
						<li><em>Event-based style</em> may benefit from a general schema for event names and parameters</li>
					</ul>
				</ul>
			</slide>
			<slide id="objects-vs-documents">
				<title>Objects vs. Documents</title>
				<ul>
					<li><em>Objects</em> follow the pattern of many common programming languages</li>
					<ul>
						<li>Objects are structured and allow nesting</li>
						<li>Object members are typed according to an existing set of types</li>
					</ul>
					<li><em>Documents</em> represent semi-structured data</li>
					<ul>
						<li>Documents often have more flexible schemas with more variations</li>
						<li>Document content is a mix of structural elements with textual data</li>
					</ul>
				</ul>
			</slide>
			<slide id="object-example">
				<title>Object Example (JSON)</title>
				<listing src="json-example.json"/>
			</slide>
			<slide id="document-example">
				<title>Document Example (XML)</title>
				<listing src="section.xml"/>
			</slide>
		</part>
		<part id="xml">
			<title>Extensible Markup Language (XML)</title>
			<slide id="xml-origins">
				<title>XML Origins and History</title>
				<ul>
					<li>Envisioned as a way for sites to publish their data models</li>
					<ul>
						<li>HTML is a simple and mostly presentation-oriented vocabulary</li>
						<li>Web sites should have the freedom to use their domain vocabularies</li>
						<li>CSS/XSLT stylesheets would then be used to render in the browser</li>
					</ul>
					<li>XML was the first open structured data format on the Internet/Web</li>
					<ul>
						<li><em>Web Services</em> took it at ran with it (and little else)</li>
						<li><em>JavaScript</em> replaced the declarative stylesheet dreams</li>
					</ul>
					<li>JSON replaced XML quickly when it became an alternative</li>
					<ul>
						<li>Direct mapping into the data structures of most programming languages</li>
						<li>No baggage of document-oriented design and related technologies (no <em>data binding</em>)</li>
						<li>Better fit for simple <q>on-the-wire</q> models</li>
					</ul>
				</ul>
			</slide>
			<slide id="xml-basics">
				<title>Basic Concepts: Elements and Attributes</title>
				<ul>
					<li>XML Documents have an <em>XML declaration</em> (optional)</li>
					<li>There is exactly one <em>document element</em> (a.k.a. <em>root element</em>)</li>
					<li>Elements may be nested (there is no conceptual limit)</li>
					<ul>
						<li>Elements may be repeated (they can be identified by position)</li>
					</ul>
					<li>Elements are marked up using <em>tags</em></li>
					<ul>
						<li>Most elements have content, surrounded by <em>start</em> and <em>end tags</em></li>
						<li>Empty elements are allowed and may use a special notation</li>
					</ul>
					<li>Elements may have attributes (zero to any number)</li>
					<ul>
						<li>Attributes can only occur once on an element (i.e., they cannot be repeated)</li>
					</ul>
				</ul>
				<listing src="my-first.xml"/>
			</slide>
			<slide id="xml-tree">
				<title>XML is Trees</title>
				<ul>
					<li>Markup is important, but only a notation</li>
					<li>XML documents are trees with different node types</li>
					<ul>
						<li>Node types so far: document, element, attribute, text</li>
					</ul>
					<img style="width : 90% ; margin : 4% ;" src="xml-tree.png" title="XML Document Tree"/>
				</ul>
			</slide>
			<slide id="xml-elements">
				<title>Elements</title>
				<ul>
					<li>Elements can use a <a href="http://www.w3.org/TR/xml/#NT-Name">wide variety of names</a></li>
					<ul>
						<li>Allowed: <code>&lt;html></code>, <code>&lt;id9832798472></code>, <code>&lt;_></code>, <code>&lt;:></code>, <code>&lt;こんにちは></code></li>
						<li>Disallowed: leading numbers, spaces, control characters</li>
					</ul>
					<li>Element names usually convey some information about the content</li>
					<ul>
						<li>This is not reliable and highly language-dependent</li>
						<li>It is <em>extremely useful</em> when working with a known vocabulary</li>
						<li>It is <em>potentially harmful</em> when working with an unknown vocabulary</li>
					</ul>
					<li>Elements are the foundation for XML's versatility</li>
					<ul>
						<li>They can be nested (<code>&lt;address>&lt;city>Berkeley&lt;/city>&lt;zip>94709&lt;/zip>…</code>)</li>
						<li>They can be repeated (<code>&lt;givenname>Erik&lt;/givenname>&lt;givenname>Thomas&lt;/givenname></code>)</li>
						<li>Their sequence can convey additional information (e.g., given names have a sequence)</li>
					</ul>
				</ul>
			</slide>
			<slide id="xml-attributes">
				<title>Attributes</title>
				<ul>
					<li>Additional information pertaining to elements</li>
					<li>Traditionally, anything that is not considered <q>content</q></li>
					<ul>
						<li>SGML is a document markup language</li>
						<li>XML uses SGML's document-based concepts</li>
						<li>XML has its roots in the document world</li>
					</ul>
					<li>Elements: Content (i.e., Data); Attributes: Metadata</li>
					<li>Documents often distinguish by what is textual content</li>
				</ul>
				<listing src="section.xml" line="12-20"/>
			</slide>
		</part>
		<slide>
			<title>Semantics</title>
			<ul>
				<li>XML is a language for encoding trees</li>
				<ul>
					<li>Elements and attributes are labeled nodes in this tree</li>
					<li>The labels can be chosen freely by document authors</li>
				</ul>
				<li>The tree's meaning is nothing XML is concerned with</li>
				<ul>
					<li>Peers must have a mutual understanding of the semantics</li>
					<li>XML without mutual understanding is almost useless</li>
					<li>Reverse engineering often is possible, but it is risky and brittle</li>
				</ul>
			</ul>
		</slide>
		<part id="json">
			<title>JavaScript Object Notation (JSON)</title>
			<slide id="json-xml">
				<title>JSON and XML</title>
				<ul>
					<li>JSON replaced XML very quickly because of its simplicity</li>
					<ul>
						<li>JSON is mostly used for <q>on-the-wire</q> models</li>
						<li>XML is intended for document representation, storage, and processing</li>
					</ul>
					<li>JSON's main advantage over XML is its object-orientation</li>
					<ul>
						<li>JSON can be directly mapped into most language's native data structures</li>
						<li>XML needs tree model processing or some form of data-binding</li>
					</ul>
					<li>JSON has no notion of vocabularies or namespaces</li>
					<ul>
						<li>XML's complexity and complications are not needed in most cases</li>
						<li>Composing JSON vocabularies is much more brittle than in XML</li>
					</ul>
				</ul>
			</slide>
			<slide id="json-basics">
				<title>JSON Basics</title>
				<ul>
					<li>JSON is the <q>data structure part</q> of JavaScript</li>
					<ul>
						<li>Perfect match for client code consuming JSON data</li>
						<li>Very good match for many other languages with structured data types</li>
					</ul>
					<li>JSON is good for <em>data-on-the-wire</em> and not so much for complex models</li>
					<li>JSON has found its way into many typical IT components</li>
					<ul>
						<li>Some databases use JSON as their native data model (<a href="https://www.mongodb.com/">MongoDB</a>)</li>
						<li>Many databases have added JSON to their data type support</li>
					</ul>
				</ul>
			</slide>
			<slide id="json-structure">
				<title>JSON Structure</title>
				<ul>
					<li>JSON has a small set of data types</li>
					<ul>
						<li><code>object</code>s are a set of name/value pairs called <em>members</em></li>
						<li><code>array</code>s are a sequence of potentially heterogeneous values</li>
						<li><code>number</code>s use regular decimal notation with an optional exponent</li>
						<li><code>string</code>s are quoted with escape for special characters and Unicode</li>
						<li><code>boolean</code>s use the two values <code>true</code> and <code>false</code></li>
					</ul>
					<li>Objects and arrays can be nested as deeply as required</li>
				</ul>
			</slide>
			<slide id="json-example">
				<title>JSON Example</title>
				<listing src="json-example.json"/>
			</slide>
		</part>
		<part id="more-representation">
			<title>More Representation Formats</title>
			<slide id="collection-formats">
				<title>Collections as a Pattern</title>
				<ul>
					<li>Collections and their management is a common design pattern</li>
					<ul>
						<li>Often some form of similarity/commonality across collection members</li>
					</ul>
					<li>Re-inventing collection formats might be a good design choice</li>
					<ul>
						<li><a href="http://webconcepts.info/specs/IETF/RFC/4287" title='Mark Nottingham and Robert Sayre, "The Atom Syndication Format", IETF RFC 4287, December 2005'>Atom</a> is XML-based and has <a href="http://dret.typepad.com/dretblog/atom-landscape.html">many additional features</a></li>
						<li><a href="https://jsonfeed.org/">JSON Feed</a> is a JSON-based variant of Atom</li>
						<li><a href="https://www.w3.org/TR/activitystreams-core/">Activity Streams</a> focuses on activity publishing/syndication</li>
					</ul>
				</ul>
			</slide>
			<slide id="http-problem">
				<title>HTTP Problem Details</title>
				<ul>
					<li><a href="http://webconcepts.info/concepts/http-status-code/">HTTP status codes</a> are useful but minimalistic</li>
					<ul>
						<li>Their well-defined semantics allow intermediaries to act on them</li>
						<li>Servers may want to convey additional information with them</li>
					</ul>
					<li>APIs may include <em>problem details</em> as part of their representation designs</li>
					<ul>
						<li>Using a standard reduces the design work on the server side</li>
						<li>Using a standard allows developers to more easily understand the design</li>
						<li>Using a standard allows problem details analysis across APIs</li>
					</ul>
					<li><a title='Mark Nottingham and Erik Wilde, "Problem Details for HTTP APIs", Internet RFC 7807, March 2016' href="http://webconcepts.info/specs/IETF/RFC/7807">RFC 7807</a> defines a JSON-centric model for problem details</li>
					<ul>
						<li><code>application/problem+json</code> is a JSON-based representation of the problem detail model</li>
						<li><code>application/problem+xml</code> is an XML-based representation of the problem detail model</li>
					</ul>
				</ul>
			</slide>
			<slide id="http-problem-json">
				<title>HTTP Problem: JSON</title>
				<listing href="https://tools.ietf.org/html/rfc7807#section-3" src="http-problem.json"/>
			</slide>
		</part>
		<part id="representations-conclusions">
			<title>Conclusions</title>
			<slide id="language-matters">
				<title>Language Matters</title>
				<ul>
					<li>APIs are languages</li>
					<li>Representations are language sentences</li>
					<li>Design and document the language of each API</li>
					<li>Choosing a metamodel is a question of API, context, and taste</li>
				</ul>
			</slide>
			<slide id="q-and-a">
				<title>Thanks! Q&amp;A</title>
				<img src="where-to.png" title="What's Next?" style="float: right ; width : 30% ; margin : 4% ; "/>
				<ul>
					<li>Slides online: <a href="http://dret.net/lectures/herman-miller-2018"><code>dret.net/lectures/herman-miller-2018</code></a></li>
					<li>Slide sources: <a href="http://github.com/dret/lectures/tree/master/herman-miller-2018"><code>dret/lectures</code></a> on <a href="http://github.com/">GitHub</a></li>
					<li>Me: <a href="http://dret.net/netdret/"><code>http://dret.net/netdret/</code></a></li>
					<li>Twitter: <a href="http://twitter.com/dret" class="twitter-follow-button" data-size="large" title="Erik Wilde on Twitter: @dret"><code>@dret</code></a></li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="hypermedia">
		<title>Hypermedia</title>
		<toc class="resources"><a href="http://webconcepts.info/specs/IETF/RFC/8288" title='RFC 8288, "Web Linking", October 2010'>RFC 8288</a>&#160;· <a href="http://www.ustream.tv/recorded/102891495" title='Mike Amundsen, "Twelve Patterns for Hypermedia Microservices", Craft Conference, April 2017'>12 Patterns</a>&#160;· <a href="http://dret.typepad.com/dretblog/2016/08/api-maps-hypermedia-api-design.html" title='Erik Wilde, "API Maps: Hypermedia API Design", August 2016'>API Maps</a></toc>
		<part id="web-linking">
			<title>Web Linking</title>
			<slide id="typed-links">
				<title>Web Links are Typed Links</title>
				<ul>
					<li>Links are <em>possible paths</em> a client can follow to accomplish a goal</li>
					<ul>
						<li>Some links are typed through HTML markup (<code>&lt;img></code>, <code>&lt;form></code>, <code>&lt;link rel=""></code>)</li>
						<li>Many links are typed for human users (<code>&lt;a></code>)</li>
					</ul>
					<li>Links show the way but do not determine the destination</li>
					<ul>
						<li>Images can use various formats represented at runtime through the media type</li>
						<li>Clients can specify capabilities/preferences via HTTP</li>
					</ul>
					<li>Hypermedia as the engine of application state (HATEOAS)</li>
					<ul>
						<li>Clients start at a resource and with a certain goal</li>
						<li>They follow links based on resources they encounter and choices they make</li>
						<li>Application state is a result of a series of interactions</li>
					</ul>
				</ul>
			</slide>
			<slide id="api-web-linking">
				<title>Web Linking for APIs</title>
				<ul>
					<li><a href="http://webconcepts.info/specs/IETF/RFC/8288">Web Linking</a> takes linking to the HTTP level</li>
					<ul>
						<li><a href="http://www.webconcepts.info/concepts/http-headers/Link"><code>Link</code> HTTP Header</a> for links on the HTTP level</li>
						<li>All links are typed and types are either registered or defined/used by individual users</li>
						<li>The <a href="http://www.iana.org/assignments/link-relations/link-relations.xhtml">link relations registry</a> establishes a shared set of meaningful link types</li>
					</ul>
					<li>Documenting hypermedia APIs always means to document all link relation types</li>
					<ul>
						<li><em>Registered link types</em> have to be put/described in the context of the API</li>
						<li><em>Extension link types</em> must be completely documented in the context of the API</li>
					</ul>
				</ul>
			</slide>
			<slide id="registered-link-types">
				<title>Registered Link Types</title>
				<ul>
					<li>Well-known link relation types are registered with IANA</li>
					<ul>
						<li>Registration can be done be anybody and follows a simple process</li>
						<li>Ideally the registry should reflect shared practices by the community</li>
					</ul>
					<li>Registered link relation types are simple strings</li>
					<ul>
						<li>Any simple name that is used should be described in the registry</li>
						<li>For specific/proprietary types it is possible to use <em>extension relation types</em></li>
					</ul>
				</ul>
			</slide>
			<slide id="extension-link-types">
				<title>Extension Link Types</title>
				<ul>
					<li>Non-registered link relation type can be invented and used by everybody</li>
					<ul>
						<li>These <em>extension link relation types</em> must be named with a URI</li>
						<li>Optionally, the URI may provide documentation for the link relation type</li>
					</ul>
					<li>Many hypermedia APIs use a mix of registered and extension types</li>
					<ul>
						<li>Use registered type when the registry provides ones that are a good fit</li>
						<li>Use extension types when no good fits can be found in the registry</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part id="hypermedia-overview">
			<title>Hypermedia Overview</title>
			<slide id="hypermedia-affordances">
				<title>Hypermedia and Affordances</title>
				<blockquote><q href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">When I say hypertext, I mean the simultaneous presentation of information and controls such that the information becomes the affordance through which the user (or automaton) obtains choices and selects actions.</q> (<a href="https://en.wikipedia.org/wiki/Roy_Fielding">Roy Fielding</a>)</blockquote>
			</slide>
			<slide id="hypermedia-workflow">
				<title>Hypermedia and Workflows</title>
				<ul>
					<li>Hypermedia combines state representation and possible further interactions</li>
					<ul>
						<li>Resource state allows clients to understand the current content</li>
						<li>Links allow clients to learn about the possible next steps</li>
						<li>Clients select and follow a link based on their application goals</li>
					</ul>
					<li>Workflows are represented by providing navigation options (affordances)</li>
					<ul>
						<li>Making it easier for clients to be <q>driven by available options</q></li>
						<li>Seamless fabric of navigation across individual APIs</li>
					</ul>
				</ul>
			</slide>
			<slide id="hypermedia-evolution">
				<title>Hypermedia and API Evolution</title>
				<ul>
					<li>Extensibility generally is a good idea for APIs</li>
					<ul>
						<li>Eliminates or reduces the need to do potentially expensive versioning</li>
					</ul>
					<li>Hypermedia representations by definition combine data and control elements</li>
					<ul>
						<li><em>Data extensibility</em> results in the usual benefits of allowing representations to evolve</li>
						<li><em>Control extensibility</em> results in the ability to add new workflow paths</li>
					</ul>
					<li>Hypermedia-based evolution has many patterns to choose from</li>
					<ul>
						<li><em>Incremental additions</em> can show up as new links in extension slots</li>
						<li><em>Complete new APIs</em> can be advertised as new start resources in <em>home documents</em></li>
					</ul>
				</ul>
			</slide>
		</part>
		<part id="hypermedia-design">
			<title>Hypermedia Design</title>
			<slide id="representing-links">
				<title>Representing Links</title>
				<ul>
					<li>Hypermedia always is about mixing data and controls in representations</li>
					<ul>
						<li>Some scenarios can strictly separate the links and the data</li>
						<li>Other scenarios need links to be embedded in data to make sense</li>
					</ul>
					<li>At the very minimum links need a <em>target URI</em> to identify the link target</li>
					<ul>
						<li>Typically links are typed implicitly or explicitly for differentiation</li>
						<li>Links may also be decorated with <em>hints</em> for additional information</li>
					</ul>
					<li>Links representations are the information that clients have to make decisions</li>
					<ul>
						<li>Some link hints may help to choose between navigation paths</li>
						<li>Some link hints may be optimizations that <q>duplicate/mirror</q> HTTP mechanisms</li>
					</ul>
					<li>Links may also be represented in <a href="http://webconcepts.info/concepts/http-header/Link">the HTTP <code>Link</code> header field</a></li>
				</ul>
			</slide>
			<slide id="json-feed">
				<title>Link Representation (JSON Feed Format)</title>
				<listing src="json-feed.json" href="https://jsonfeed.org/version/1"/>
			</slide>
			<slide id="typed-links">
				<title>Typed Links</title>
				<ul>
					<li>Links represents navigational options for clients</li>
					<ul>
						<li>APIs include links that are advertised based on service and state</li>
						<li>Clients choose links based on application state and goals</li>
					</ul>
					<li>Link typing on the Web often is done using <a href="http://webconcepts.info/specs/IETF/RFC/8288">RFC 8288 <q>Web Linking</q></a></li>
					<ul>
						<li><em href="http://tools.ietf.org/html/rfc8288#section-2.1.1">Registered types</em> are simple strings using <a href="https://www.iana.org/assignments/link-relations/link-relations.xhtml">well-known values</a></li>
						<li><em href="http://tools.ietf.org/html/rfc8288#section-2.1.2">Extension types</em> are URIs which might choose to self-document their meaning</li>
					</ul>
					<li><a href="http://webconcepts.info/concepts/link-relation/">Registered types</a> have documented but fuzzy meaning</li>
					<ul>
						<li>APIs need to document which types they use and what they mean</li>
						<li>Reusing existing types makes the <q>API language</q> easier to understand and use</li>
					</ul>
				</ul>
			</slide>
			<slide id="hal">
				<title>Typed Links (HAL Format)</title>
				<listing src="hal.json" href="http://stateless.co/hal_specification.html" line="17-37"/>
			</slide>
		</part>
		<part id="hypermedia-formats">
			<title>Hypermedia Formats</title>
			<slide id="generic-specific">
				<title>Specific Hypermedia Formats</title>
				<ul>
					<li>Any format that mixes control and data is a hypermedia format</li>
					<ul>
						<li>Standard issues of how to define representations</li>
						<li>Additional issues of where and how to embed links as controls</li>
					</ul>
					<li>Depending on the metamodel and schema language varying support</li>
					<ul>
						<li>Not everybody likes using schema languages</li>
						<li>Many schema languages are focusing on grammars and data types</li>
						<li>Some schema languages at least have data types for URIs</li>
						<li>Few schema languages have explicit support for hypermedia</li>
					</ul>
				</ul>
			</slide>
			<slide id="generic-hypermedia">
				<title>Generic Hypermedia Formats</title>
				<ul>
					<li>Instead of designing hypermedia it's possible to use existing formats</li>
					<ul>
						<li>Generic formats often provide little more than data/control separation</li>
						<li>Domain focus results in semi-generic formats such as collection formats</li>
					</ul>
					<li>Hypermedia is more a pattern than it is format or technology</li>
					<ul>
						<li>Specific technologies may come with more constraints than benefits</li>
						<li>Never underestimate the benefits of reusing shared languages</li>
					</ul>
					<li>So far there is no clear trend towards a common generic format</li>
				</ul>
			</slide>
		</part>
		<part id="hypermedia-conclusions">
			<title>Conclusions</title>
			<slide id="evolution-focus">
				<title>The Web Pattern</title>
				<ul>
					<li>Hypermedia is a pattern mixing data and controls</li>
					<li>Hypermedia provides a good foundation for API evolvability</li>
					<li>Clients need a more data-driven control flow</li>
				</ul>
			</slide>
			<slide id="q-and-a">
				<title>Thanks! Q&amp;A</title>
				<img src="where-to.png" title="What's Next?" style="float: right ; width : 30% ; margin : 4% ; "/>
				<ul>
					<li>Slides online: <a href="http://dret.net/lectures/herman-miller-2018"><code>dret.net/lectures/herman-miller-2018</code></a></li>
					<li>Slide sources: <a href="http://github.com/dret/lectures/tree/master/herman-miller-2018"><code>dret/lectures</code></a> on <a href="http://github.com/">GitHub</a></li>
					<li>Me: <a href="http://dret.net/netdret/"><code>http://dret.net/netdret/</code></a></li>
					<li>Twitter: <a href="http://twitter.com/dret" class="twitter-follow-button" data-size="large" title="Erik Wilde on Twitter: @dret"><code>@dret</code></a></li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="change-management">
		<title short="Change Management">Change Management and Versioning</title>
		<toc class="resources"><a href="https://tools.ietf.org/html/rfc5829" title="RFC 5829: 'Link Relation Types for Simple Version Navigation between Web Resources', April 2010">RFC 5829</a>&#160;· <a href="http://dret.typepad.com/dretblog/2016/04/robust-extensibility.html" title='Erik Wilde, "Patterns for Robust Extensibility", April 2016'>Robust Extensibility</a>&#160;· <a href="https://tools.ietf.org/html/draft-wilde-registries" title='Erik Wilde, "The Use of Registries", Internet Draft wilde-registries'>Registries</a>&#160;· <a href="https://blog.goodapi.co/api-change-management-2fe5bba32e9b" title='Zdenek Nemec, "API Change Management", April 2017'>Change Management</a>&#160;· <a href="http://semver.org/" title='Semantic Versioning 2.0.0'>Semantic Versioning</a>&#160;· <a href="http://webconcepts.info/specs/IETF/I-D/draft-wilde-sunset-header" title='Erik Wilde, "The Sunset HTTP Header", Internet Draft wilde-sunset-header'>Sunset Header</a></toc>
		<part id="change-management-introduction">
			<title>Introduction</title>
			<slide id="versioning-practice">
				<title>Versioning in Practice</title>
				<ul>
					<li>Version numbers have an almost mythical role in IT</li>
					<ul>
						<li>But often they are only useful for signaling continuity or breakage points</li>
						<li>Most things work or break in a binary way (or simply refuse to even try)</li>
					</ul>
					<li>Compatibility comes in two basic flavors (one easier, one harder)</li>
					<ul>
						<li><em>Backwards compatibility</em> means to work with older components</li>
						<li><em>Forward compatibility</em> means to work with more advanced components</li>
					</ul>
					<li>The Web has good rules to support both compatibility types</li>
					<ul>
						<li><em>Backwards compatibility:</em> New browser accessing older content</li>
						<li><em>Forward compatibility:</em> Old browser accessing newer content</li>
					</ul>
				</ul>
			</slide>
			<slide id="versioning-tweet-fielding">
				<title>Versioning Breaks Things</title>
				<img title='Roy Fielding (@fielding): &apos;The reason to make a real REST API is to get evolvability … a &quot;v1&quot; is a middle finger to your API customers, indicating RPC/HTTP (not REST)&apos;' href="https://twitter.com/fielding/status/376835835670167552" src="versioning-tweet-fielding.png" class="fullsize"/>
			</slide>
			<slide id="evolution">
				<title>Plan for Evolution</title>
				<ul>
					<li>Planning for evolution means to reduce pain in the future</li>
					<ul>
						<li>No immediate benefits other than <q>doing the right thing</q></li>
						<li>Modest effort when part of the API design process and culture</li>
					</ul>
					<li>Extensibility should be part of the <em>API design culture</em></li>
					<ul>
						<li>Each API must have and document a plan for API evolution</li>
						<li>The simplest possible plan may be to never change the API</li>
					</ul>
					<li>Extensibility should be made easy for API consumers</li>
					<ul>
						<li>Provide test cases that simulate correct/incorrect API extensions</li>
						<li>Provide feature flags so that services can enter <q>test mode</q></li>
					</ul>
				</ul>
			</slide>
		</part>
		<part id="robust-extensibility">
			<title>Robust Extensibility</title>
			<slide id="core-semantics">
				<title>Meaningful Core Semantics</title>
				<ul>
					<li>The core of the API allows clients to have meaningful interactions</li>
					<ul>
						<li>The starting point of an API should be meaningful and complete</li>
					</ul>
					<li>The core of the API is robust over time</li>
					<ul>
						<li>Anything that is added to the core does not change the core semantics</li>
					</ul>
					<li>Anything that is not part of the core can be safely ignored</li>
					<ul>
						<li><code>mustIgnore</code> semantics allow safe interactions beyond closely coordinated groups</li>
					</ul>
				</ul>
			</slide>
			<slide id="extension-points">
				<title>Well-Defined Extension Points</title>
				<ul>
					<li>APIs should be clear about where extensions are allowed</li>
					<ul>
						<li>API metamodels often decide where (potential) extension points are</li>
						<li>API schemas/definitions should further narrow down where extensions are allowed</li>
					</ul>
					<li>API tests can make sure that the extension points are properly implemented</li>
					<ul>
						<li>Extensions in allowed places are ignored and tests should succeed</li>
						<li>Extensions in other places should raise errors about malformed content</li>
					</ul>
					<li>Extension points are interesting to support in generic software</li>
					<ul>
						<li>Monitoring can report which and where extensions are being used</li>
						<li>Libraries can make it easy to create/parse extension data</li>
					</ul>
				</ul>
			</slide>
			<slide id="processing-model">
				<title>Well-Defined Processing Model</title>
				<ul>
					<li>Extensions are well-defined and their handling is well-defined as well</li>
					<ul>
						<li>Extension points make it clear where to expect extensions</li>
						<li>Processing models make it clear what to do with extensions</li>
					</ul>
					<li><code>mustIgnore</code> is a popular and good choice for extension processing</li>
					<ul>
						<li>Some formats allow extensions to declare their processing model (such as <code>mustUnderstand</code>)</li>
						<li>HTML has a rule of ignoring unknown elements but processing their content</li>
					</ul>
					<li>How to <em>learn</em> about extensions is a different matter</li>
					<ul>
						<li>If an API evolves along a single path it may be as simple as looking along that path</li>
						<li>If an API is used <a href="https://tools.ietf.org/html/draft-wilde-registries">in more complex ways</a> a registry may be a way to find extensions</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part id="versioning-strategies">
			<title>Versioning Strategies</title>
			<slide id="version-identification">
				<title>Identifying Versions</title>
				<ul>
					<li>Versioning may be necessary when the extension model is not working anymore</li>
					<li>Three main ways how to distinguish between versions on the service surface</li>
					<ul>
						<li>Make version numbers part of the resource URI: <code>http://example.org/api/v2/</code></li>
						<li>Use specific HTTP headers: <code>API-Version: 2.0.0</code></li>
						<li>Use media types: <code>Accept: application/vnd.example.org.v2+json</code></li>
					</ul>
					<li>All of these have side-effects which have to be balanced</li>
					<ul>
						<li>New URIs change resource identity which may result in data integration problems</li>
						<li>Custom headers are specific for a service and hard to see/support in the general Web fabric</li>
						<li>Media types often are not used by APIs or the clients consuming them</li>
					</ul>
					<li>Most APIs choose URI-based versioning and introduce new <q>API identity</q></li>
					<ul>
						<li>Versioning at this level is little more than <q>keeping the API brand</q></li>
						<li>Version numbers can be used in URI path or in the domain name</li>
					</ul>
				</ul>
			</slide>
			<slide id="semantic-versioning">
				<title><a href="http://semver.org/">Semantic Versioning</a></title>
				<ul>
					<li><a href="http://semver.org/">Semantic Versioning</a> standardizes the meaning of version numbers</li>
					<li>Version numbers follow the <code>MAJOR.MINOR.PATCH</code> pattern and the following rules</li>
					<ul>
						<li>Increase <code>MAJOR</code> version for incompatible API changes</li>
						<li>Increase <code>MINOR</code> version for adding functionality in a backwards-compatible manner</li>
						<li>Increase <code>PATCH</code> version for making backwards-compatible bug fixes</li>
					</ul>
					<li>Mostly about how to name implementation artifacts and of limited use for APIs</li>
					<ul>
						<li>Exposing detailed version/patch information is a potential security risk</li>
						<li>No behavioral benefit other than allowing clients to raise errors and stop working</li>
					</ul>
				</ul>
			</slide>
			<slide id="linking-versions">
				<title>Linking Versions</title>
				<ul>
					<li>Communicating versions via links works better than naming schemes</li>
					<ul>
						<li>APIs remain self-contained as long as consumers are working with one version</li>
						<li>APIs are brought into context when consumers want versioning information</li>
					</ul>
					<li><a href="https://tools.ietf.org/html/rfc5829" title="RFC 5829: 'Link Relation Types for Simple Version Navigation between Web Resources', April 2010">RFC 5829</a> defines link relations for <q>simple version navigation</q></li>
					<ul>
						<li><code>successor-version</code> links to the newer version of the API</li>
						<li><code>latest-version</code> links to the newest version of the API</li>
						<li><code>predecessor-version</code> links to the older version of the API</li>
						<li><code>version-history</code> links to a resource about the version history</li>
					</ul>
					<li>Plays well with <em>home documents</em> and their role for an API</li>
					<ul>
						<li>APIs share home documents or at least version histories across versions</li>
						<li>Versioning links are used to allow navigation across all API versions</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part id="decommissioning">
			<title>Decommissioning</title>
			<slide id="http-sunset">
				<title>Signaling API End-of-Life</title>
				<ul>
					<li>APIs can change in terms of features and will be decommissioned at some point</li>
					<ul>
						<li><a href="http://dret.typepad.com/dretblog/2016/04/robust-extensibility.html">Robust extensibility</a> helps to facilitate non-breaking API changes</li>
						<li><em>Hypermedia</em> helps as a pattern to move extensibility beyond data models</li>
						<li><a href="http://semver.org/">Semantic versioning</a> may be used to keep track of API changes</li>
						<li><a href="http://dret.typepad.com/dretblog/2015/08/http-sunset-header.html">HTTP <code>Sunset</code>ting</a> can be used to <a href="http://webconcepts.info/concepts/http-header/Sunset">signal upcoming sunsets on the HTTP level</a></li>
					</ul>
					<li>One possible requirement is that APIs must support <code href="http://webconcepts.info/concepts/http-header/Sunset">Sunset</code></li>
					<ul>
						<li>Services must document/describe the support of <code>Sunset</code></li>
						<li>Services may implement <code>Sunset</code> any way they like</li>
						<li>The simplest option may be <em><code>Sunset</code> policies</em> on a gateway</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part id="change-management-conclusions">
			<title>Conclusions</title>
			<slide id="plan-for-evolution">
				<title>Plan for Evolution</title>
				<ul>
					<li>Evolvable APIs do not just happen</li>
					<li>Think about cost and economics for versioning</li>
					<li>Make evolution/versioning/deprecation part of API culture</li>
				</ul>
			</slide>
			<slide id="q-and-a">
				<title>Thanks! Q&amp;A</title>
				<img src="where-to.png" title="What's Next?" style="float: right ; width : 30% ; margin : 4% ; "/>
				<ul>
					<li>Slides online: <a href="http://dret.net/lectures/herman-miller-2018"><code>dret.net/lectures/herman-miller-2018</code></a></li>
					<li>Slide sources: <a href="http://github.com/dret/lectures/tree/master/herman-miller-2018"><code>dret/lectures</code></a> on <a href="http://github.com/">GitHub</a></li>
					<li>Me: <a href="http://dret.net/netdret/"><code>http://dret.net/netdret/</code></a></li>
					<li>Twitter: <a href="http://twitter.com/dret" class="twitter-follow-button" data-size="large" title="Erik Wilde on Twitter: @dret"><code>@dret</code></a></li>
				</ul>
			</slide>
		</part>
	</presentation>
</hotspot>